---
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# DOM-Based Cross Site Scripting

El modelo de objetos de documento (DOM) es una interfaz de programación de aplicaciones multiplataforma e independiente del lenguaje que trata un documento HTML, XHTML o XML como una estructura de árbol. Los ataques basados ​​en DOM suelen ser ataques XSS reflejados que se activan mediante el envío de un enlace con entradas que se reflejan en el navegador web. En los ataques XSS basados ​​en DOM, la carga útil nunca se envía al servidor.

En un ataque XSS basado en DOM, el atacante envía una URL maliciosa a la víctima y, después de que la víctima hace clic en el enlace, el atacante puede cargar un sitio web malicioso o un sitio que tiene un controlador de ruta DOM vulnerable. Una vez que el navegador representa el sitio vulnerable, la carga útil ejecuta el ataque en el contexto del usuario en ese sitio.

Debido a su naturaleza, las vulnerabilidades XSS basadas en DOM se pueden ejecutar en muchos casos sin que el servidor pueda determinar qué se está ejecutando realmente. Esto puede hacer que muchas de las técnicas generales de detección y filtrado XSS sean impotentes ante este tipo de ataques.

Este ejemplo hipotético utiliza el siguiente código del lado del cliente:

```
<script>
document.write("Site is at: " + document.location.href + ".");
</script>
```

Un atacante puede agregar `#<script>alert('xss')</script>`a la página afectada la URL que, cuando se ejecute, mostrará el cuadro de alerta. En este caso, el código adjunto no se enviaría al servidor ya que `#`el navegador no trata todo lo que sigue al carácter como parte de la consulta, sino como un fragmento. En este ejemplo, el código se ejecuta inmediatamente y la página muestra una alerta de "xss". A diferencia de los tipos más comunes de secuencias de comandos entre sitios ( [reflejadas y almacenadas](https://owasp.org/www-community/attacks/xss/) en las que el código se envía al servidor y luego de regreso al navegador), esto se ejecuta directamente en el navegador del usuario sin contacto con el servidor.

Las [consecuencias](https://owasp.org/www-community/attacks/xss/) de las fallas XSS basadas en DOM son tan amplias como las que se observan en formas más conocidas de XSS, incluida la recuperación de cookies, más inyección de scripts maliciosos, etc., y por lo tanto deben tratarse con la misma severidad.

### Cómo probar <a href="#how-to-test" id="how-to-test"></a>

Las aplicaciones JavaScript se diferencian significativamente de otros tipos de aplicaciones porque a menudo el servidor las genera dinámicamente. Para comprender qué código se está ejecutando, es necesario rastrear el sitio web que se está probando para determinar todas las instancias de JavaScript que se ejecutan y dónde se aceptan las entradas del usuario. Muchos sitios web dependen de grandes bibliotecas de funciones, que a menudo abarcan cientos de miles de líneas de código y no se han desarrollado internamente. En estos casos, las pruebas de arriba hacia abajo a menudo se convierten en la única opción viable, ya que muchas funciones de nivel inferior nunca se utilizan, y analizarlas para determinar cuáles son sumideros consumirá más tiempo del que suele estar disponible. Lo mismo puede decirse de las pruebas de arriba hacia abajo si, para empezar, no se identifican los insumos o la falta de ellos.

La entrada del usuario se presenta en dos formas principales:

* Entrada escrita en la página por el servidor de una manera que no permita XSS directo, y
* Entrada obtenida de objetos JavaScript del lado del cliente.

Aquí hay dos ejemplos de cómo el servidor puede insertar datos en JavaScript:

```
var data = `“<escaped data from the server>”`;
var result = someFunction(`“<escaped data from the server>”`);
```

Aquí hay dos ejemplos de entrada de objetos JavaScript del lado del cliente:

```
var data = window.location;`
var result = someFunction(window.referrer);
```

Si bien hay poca diferencia con el código JavaScript en la forma en que se recuperan, es importante tener en cuenta que cuando la entrada se recibe a través del servidor, el servidor puede aplicar cualquier permutación a los datos que desee. Por otro lado, las permutaciones realizadas por los objetos JavaScript se comprenden y documentan bastante bien. Si `someFunction`en el ejemplo anterior fuera un sumidero, entonces la explotabilidad en el primer caso dependería del filtrado realizado por el servidor, mientras que en el último caso dependería de la codificación realizada por el navegador en el objeto `window.referrer`. Stefano Di Paulo ha escrito un excelente artículo sobre lo que devuelven los navegadores cuando se les pregunta por los diversos elementos de una [URL utilizando los atributos de documento y ubicación](https://code.google.com/p/domxsswiki/wiki/LocationSources) .

Además, JavaScript a menudo se ejecuta fuera de `<script>`bloques, como lo demuestran los muchos vectores que han llevado a omisiones del filtro XSS en el pasado. Al rastrear la aplicación, es importante tener en cuenta el uso de scripts en lugares como controladores de eventos y bloques CSS con atributos de expresión. Además, tenga en cuenta que será necesario evaluar cualquier objeto CSS o script externo para determinar qué código se está ejecutando.

Las pruebas automatizadas tienen un éxito muy limitado a la hora de identificar y validar XSS basado en DOM, ya que normalmente identifican XSS enviando una carga útil específica e intentan observarla en la respuesta del servidor. Esto puede funcionar bien para el ejemplo simple que se proporciona a continuación, donde el parámetro del mensaje se refleja en el usuario:

```
<script>
var pos=document.URL.indexOf("message=")+5;
document.write(document.URL.substring(pos,document.URL.length));
</script>
```

Sin embargo, es posible que no se detecte en el siguiente caso artificial:

```
<script>
var navAgt = navigator.userAgent;

if (navAgt.indexOf("MSIE")!=-1) {
        document.write("You are using IE as a browser and visiting site: " + document.location.href + ".");
}
else
{
    document.write("You are using an unknown browser.");
}
</script>
```

Por este motivo, las pruebas automatizadas no detectarán áreas que puedan ser susceptibles a XSS basado en DOM a menos que la herramienta de prueba pueda realizar análisis adicionales del código del lado del cliente.

<mark style="color:red;">**Recursos**</mark>

{% embed url="https://portswigger.net/web-security/cross-site-scripting/dom-based" %}

{% embed url="https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html" %}

{% embed url="https://www.acunetix.com/blog/articles/dom-xss-explained/" %}
